export declare class Packet {
    count: number;
    timeMs: number;
    data: number[];
    constructor(count: number, data: number[]);
    packetCounter: () => number;
    deltaTime: () => number;
    accelX: () => number;
    accelY: () => number;
    accelZ: () => number;
    gyroX: () => number;
    gyroY: () => number;
    gyroZ: () => number;
    mag1X: () => number;
    mag1Y: () => number;
    mag1Z: () => number;
    mag2X: () => number;
    mag2Y: () => number;
    mag2Z: () => number;
    accelArray: () => number[];
    gyroArray: () => number[];
    fullMap: () => {
        count: number;
        packet_counter: number;
        delta_time: number;
        accel_X: number;
        accel_Y: number;
        accel_Z: number;
        gyro_X: number;
        gryo_Y: number;
        gyro_Z: number;
        mag1_X: number;
        mag1_Y: number;
        mag1_Z: number;
        mag2_X: number;
        mag2_Y: number;
        mag3_Z: number;
    };
}
export declare class ActivityDetection {
    REP_COUNTER_DEFAULT_PEAK_PROMINENCE_FACTOR: number;
    REP_COUNTER_DEFAULT_WINDOW_WIDTH: number;
    GLOBAL_DEFAULT_PACKET_SAMPLE_RATE: number;
    MIN_EXTECTED_PEAK_PROMINENCE: number;
    DEFAULT_EMA_FACTOR: number;
    MIN_ACF_COEFF: number;
    GYRO_CONVERSION_RATIO: number;
    ACC_CONVERSION_RATIO: number;
    DEFAULT_FREQUENCY: number;
    REST: number;
    PLANK: number;
    RANDOM_MOVEMENT: number;
    REST_MAXIMUM_STD: number;
    PLANK_MAXIMUM_STD: number;
    private packets;
    private packetCounter;
    private ema;
    private last_len;
    private q_c;
    private q_base;
    private q_u_world;
    private pre_data_std;
    private last_position;
    private last_plank_angle;
    private getWindowSize;
    getPreviousSampleCount: () => number;
    private globalConstants;
    private repCounterConstants;
    putGlobalConstant: ([name, value]: [string, number]) => void;
    putRepCalculationConstant: ([name, value]: [string, any]) => void;
    pushData: (data: number[]) => void;
    getRepCounterIntervalMilliseconds: () => number;
    getAngleMeasurementIntervalMilliseconds: () => number;
    getPacketCount: () => number;
    getSampleCount: () => number;
    getRawData: () => {
        count: number;
        packet_counter: number;
        delta_time: number;
        accel_X: number;
        accel_Y: number;
        accel_Z: number;
        gyro_X: number;
        gryo_Y: number;
        gyro_Z: number;
        mag1_X: number;
        mag1_Y: number;
        mag1_Z: number;
        mag2_X: number;
        mag2_Y: number;
        mag3_Z: number;
    }[];
    calculateReps: () => any;
    private acf;
    private emaCalc;
    private range;
    private detectPeaks;
    private zeroCrossings;
    initializePlankParameters: () => void;
    isInPlankPosition: (t: number) => any;
    private calcAngle;
}
